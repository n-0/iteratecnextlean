-- How to create your own datastructures (Sort 1) then?

-- we have inductive data types (similar to enums or discriminated unions)
inductive AnimalKind where
  | Dog 
  | Cat
  | Elephant
  | Mouse
deriving Repr


-- A data type consisting of multiple fields
structure Animal where
  name : String
  kind: AnimalKind 
deriving Repr

-- how to `construct` a structure 
def clifford : Animal := { name := "Clifford", kind := AnimalKind.Dog }
-- this is the function called under the hood of other syntaxes
def garfield := Animal.mk "Garfield" AnimalKind.Cat 
def dumbo := ({ name := "Dumbo", kind := AnimalKind.Elephant } : Animal)
-- these symbols `⟨ ⟩` are generated by `\< ` `\> `, often used for mathematical structures
def mickey : Animal := ⟨ "Mickey Mouse", AnimalKind.Mouse ⟩ 

-- reusing previous instances/objects
def jerry : Animal := { garfield with name := "Jerry" } 


-- EXERCISE: Add another animal kind and create an instance/object for it!

-- Is there something like inheritance or interfaces?
-- Actually they're the same thing in Lean, the so called `type classes`
-- structures are under the hood also just special type classes
-- (put differently, a type class is like an interfaces and properties are methods with no arguments)
-- as you can implement multiple type classes at the same time, you can have non-linear inheritance
class Sounding where
  sound: Unit → String

-- Surely you wondered about the `deriving` keyword.
-- Those are type classes that have some default implementation for their methods.
-- Usually they work via some macro expansion, as the Repr allows you to get
-- a nice (internal) representation from the elaborator of your structure (it's similar toString, but not the same)
#eval (repr mickey)


-- Here a default implementation of the Repr type class for the Sounding type class
-- (yes type classes can have default implementations of other type classes, not only structures)
instance : Repr Sounding where
  reprPrec := fun x _ => x.sound ()

structure AnimalWithSound extends Animal, Sounding
deriving Repr

-- Here an instance of our structure with an implementation for the sound "method" of
-- the Sounding type class
def mickeyWithSound : AnimalWithSound := { mickey with sound := fun _ => "Oh boy!" }

-- EXERCISE: create a type class SayHello, with a method `hello`
-- of type : Animal → String,
-- Adjust then one of the existing structures such that it extends SayHello
-- and add an implementation for `hello` to mickeyWithSound (or another animal of your choice)
