-- How to create your own datastructures (Sort 1) then?

-- we have inductive data types (similar to enums or discriminated unions)

inductive ScientificDomain where
  | Mathematics
  | Physics
  | Computer
  | Biology 
  | Chemistry
  | Astronomy
  | Psychology
  | Medicine
deriving Repr


structure Scientist where
  name : String
  scientificDomain : ScientificDomain
deriving Repr

-- how to `construct` a structure 
def einstein : Scientist := { name := "Albert Einstein", scientificDomain := ScientificDomain.Physics }
-- this is the function called under the hood of other syntaxes
def turing := Scientist.mk "Alan Turing" ScientificDomain.Computer
def hilbert := ({ name := "David Hilbert", scientificDomain := ScientificDomain.Mathematics } : Scientist)
-- these symbols `⟨ ⟩` are generated by `\< ` `\> `, often used for mathematical structures
def franklin : Scientist:= ⟨ "Rosalind Franklin", ScientificDomain.Medicine ⟩ 

-- reusing previous instances
def coquand : Scientist := { turing with name := "Thierry Coquand" } 

-- Is there something like inheritance or interfaces?
-- Actually they're the same thing in Lean, the so called type classes
-- structures are under the hood also just special type classes
-- (put differently, a type class is like an interfaces and properties are methods with no arguments)
-- as you can implement multiple type classes at the same time, you can have non-linear inheritance
class Quotable where
  quote: Unit → String

structure ExtendedScientist extends Scientist, Quotable


-- Surely you wonder about the `deriving` keyword.
-- Those are type classes that have some default implementation for their methods.
-- Usually they work via some macro expansion, as the Repr allows you to get
-- a nice string representation of your structure (toString())
#eval (repr einstein)